# Idea

## Probing 기법

선형 공간의 데이터를 저장하는 경우에 빈 공간을 찾는 테크닉이다.  
이 문제에선 TicketTable을 생성하고 used 배열을 순회하면서 해당 인덱스가 빈 공간인지 여부를 확인하고 셋팅하는 방식으로 구현했다. 또한 ,마지막 인덱스에 도달하는 경우 다시 첫 번째 인덱스로 돌아가는 Circular 탐색 또한 알아자.

## 배열 인덱스와 나머지

이 문제의 경우 회원 번호를 티켓 수로 나눈 나머지를 티켓 번호라고 지정했다. 이는 배열을 순회하는 경우에 순회를 용이하게 하는 특징을 가지고 있다. 일반적인 경우에 마지막 인덱스를 순회하고 첫 번째 인덱스로 돌아가기 위해선 인덱스를 0으로 바꾸는 예외 처리가 필요하지만 인덱스가 배열의 크기의 나머지인 경우엔 if 문을 통한 예외가 필요하지 않다. 만약 배열이 n - 1로 마지막 인덱스의 순회를 마치고 다음 인덱스인 n을 탐색하는 경우 n % n 을 연산하고 그 값은 0이되기 때문이다.

# Practice

행사 기획자인 수정이는 이 번에 자신이 담당하게 된 행사에서 행운권 추첨을 기획하고 있다. 이번 행사에서는 최대 수천명 정도의 사람이 방문할 수 있기 때문에 어떻게 하면 공평하고 불규칙적으로 행운권 번호를 배정할 수 있을지가 큰 관건이었다. 하지만 똑똑한 수정이는 아래와 같은 아이디어를 냈다.

- 모든 행운권 번호는 **_0~(N-1)_**의 정수로 총 **_N_**개이다.
- 모든 고객은 회원번호를 가지고 있으며 회원 번호는 자연수이다.
- 입장한 고객은 자신의 회원 번호를 **_N_**으로 나눈 나머지를 계산해 그 번호와 같은 행운권을 지급받는다.
  - 해당 행운권이 다른 사람에게 지급된 상황이라면 그것보다 +1한 번호를 지급받는다.
  - 아직 아무에게도 지급되지 않은 번호를 찾을 때 까지 행운권 번호를 +1씩 증가시켜가며 찾는다.
  - 만약 **_(N-1)_**번 행운권도 이미 지급된 상태라면 0번 행운권부터 다시 조회한다.
  - 이렇게 순서대로 조회하다가 가장 먼저 발견된 아직 지급되지 않은 행운권을 지급받는다.
- 고객들은 순서대로 한 명씩 입장하며 한번 지급된 행운권 번호는 교환할 수 없다.

<**_N=5000_**일 때 행운권 번호를 지급받는 예시>

수정이는 행사 중간에도 바쁠 예정이기에 당신에게 이를 자동화할 수 있는 프로그램을 작성해달라고 요청했다. 수정이를 도와주자.

### **입력 형식**

첫 줄에는 준비한 행운권의 수 **_N_**과 입장 할 회원의 수 **_M_**이 공백으로 구분되어 주어진다. **_N_**은 1이상 5,000이하의 자연수이며 **_M_**은 1이상 1,000이하의 자연수이다. 또한, **_M_**은 항상 **_N_**이하의 값을 가진다.

이후 총 **_M_**줄에 걸쳐서 입장 한 회원들의 회원번호가 순서대로 주어진다. 각 회원번호는 1이상 1억 이하의 자연수이다.

### **출력 형식**

입장한 회원들의 순서대로 해당 회원이 지급받게 될 행운권 번호를 한 줄에 하나 씩 정수 형태로 출력한다.
