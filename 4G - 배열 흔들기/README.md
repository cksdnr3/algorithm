# Idea

## 문제의 요구사항에 집중 (추상화)

### 자료구조를 설계하는 가장 기본적인 아이디어는 OOP의 클래스 설계와 같다.

- 정의된 메소드가 정확한 결과를 반환함을 보장한다.
- 이외의 내용은 사용자의 입장에서 분리하여 캡슐화 한다.

요구하는 기능이 정확하게 동작한다면 내부 구현 방법은 상황과 목적에 따라 달라질 수 있다.  
이 문제의 경우 정확한 결과를 얻을 수 있다면 직접 배열을 시프트하는 대신 다른 방법을 통해 구현할 수도 있다.  
즉, 정확한 결과를 얻는 것이 중요하다.

## 순환 인덱싱

이 문제의 경우 가장 끝 요소들을 shift 하는 경우 배열을 순환하며 shift하 도록 할 수 있는 배열을 만드는 것이다.  
순환하는 배열은 해당 배열이 같은 요소가 반복적으로 전개되는 배열인 것 처럼 가정해볼 수 있고, 특정 범위를 슬라이드 하는 것처럼 가정해 볼 수 있다.  
인덱스가 순환하므로 배열의 첫 인덱스를 기준으로 상대적인 위치를 알아낼 수 있고 이를 통해서 실제로 배열을 shift 하지 않고 상대적 위치를 통해서 그 위치의 요소를 알아낼 수 있다.  
순환하는 인덱스는 나머지 계산을 통해 인덱스의 범위를 안전하게 계산할 수 있다.

# Practice

프로그래머 지수는 제비뽑기 프로그램을 만들고 있다. 자신이 이미 정해둔 **_N_**개의 배열에 각각 임의의 번호들을 저장해 두고 사용자들이 **_0~(N-1)_**의 정수 번호를 하나 입력하면 그 칸에 있는 숫자를 알려주게 된다. 하지만 자신의 제비뽑기 프로그램을 사람들이 사용하는 모습을 지켜보던 지수는 배열에 저장된 데이터들이 고정적이기 때문에 게임을 반복할 수록 사람들이 숫자를 추정할 수 있다는 문제점을 발견했다.

그래서 지수는 아래와 같은 두 가지 기능을 구현하여 주기적으로 배열에 저장된 원소들의 위치들을 바꿔주고자 한다.

- 배열의 원소들을 모두 왼쪽으로 한 칸씩 옮긴다. 이 때 0번 칸에 있던 원소는 **_(N-1)_**번 칸으로 이동된다.
- 배열의 원소들을 모두 오른쪽으로 한 칸씩 옮긴다. 이 때 **_(N-1)_**번 칸에 있던 원소는 0번 칸으로 이동된다.

하지만 위의 두 동작은 너무 단순하기 때문에 실제로는 위의 기능을 응용하여 아래와 같은 네 가지 명령어를 구현하고자 한다.

- 입력으로 **`0 P`** 가 주어지면 화면에 현재 배열의 **_P_**번 칸에 있는 원소를 한 줄에 출력해준다.
- 입력으로 **`1 K`** 가 주어지면 현재 배열을 왼쪽으로 한 칸씩 옮기는 동작을 총 **_K_**번 수행한다.
- 입력으로 **`2 K`** 가 주어지면 현재 배열을 오른쪽으로 한 칸씩 옮기는 동작을 총 **_K_**번 수행한다.
- 입력으로 **`3`** 이 주어지면 배열을 한 칸도 좌우로 이동하지 않았던 초기 상태로 되돌린다.

아직 프로그래밍이 서툰 지수를 도와 위의 네 명령어를 처리하는 프로그램을 작성해주자.

### **입력 형식**

첫 줄에는 배열의 크기 **_N_**과 처리할 명령어의 수 **_M_**이 공백으로 구분 된 두 자연수로 주어진다. **_N_**과 **_M_**은 모두 1,000이하의 자연수이다.

두 번째 줄에는 초기 배열에 존재하는 **_N_**개의 자연수들이 공백으로 구분되어 순서대로 주어진다. 배열의 모든 원소는 1,000이하의 자연수이다.

이후 총 **_M_**줄에 걸쳐서 한 줄에 하나씩 네 가지 명령어 중 하나가 주어진다.

- 각 명령어의 처리 방법은 문제 설명과 예시를 참고한다.
- **`0 P`** 명령어에서 **_P_**는 0이상 **_(N-1)_**이하의 정수이다.
- **`1 K`**, **`2 K`** 명령어에서 **_K_**는 1만 이하의 자연수이다.

### **출력 형식**

입력으로 명령어 **`0 P`** 가 주어질 때 마다 배열의 **_P_**번 칸에 존재하는 원소를 한 줄에 출력한다.
